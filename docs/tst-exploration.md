# Complete TST-NSLS-BITS Package Creation Plan

Based on the exploration and user's request to include git clone, BITS CLI usage, and IPython profile configuration, here's the comprehensive plan:

## 1. Initial Setup Phase

### Step 1.1: Clone BITS-Starter Template
```bash
cd bits_deployments/
git clone ../bits_base/BITS-Starter/ tst-nsls-bits
cd tst-nsls-bits
```

### Step 1.2: Install BITS Environment and CLI
```bash
# Create and activate environment  
export ENV_NAME=BITS_tst_env
conda create -y -n $ENV_NAME python=3.11
conda activate $ENV_NAME
pip install apsbits

# Verify create-bits CLI is available
create-bits --help
```

### Step 1.3: Create TST Instrument using BITS CLI
```bash
# Use the create-bits CLI to generate the instrument structure
export INSTRUMENT_NAME=tst_instrument
create-bits $INSTRUMENT_NAME

# This creates:
# - src/tst_instrument/ (instrument package)
# - src/tst_instrument_qserver/ (queue server config)
```

## 2. IPython Profile Configuration

### Step 2.1: Create TST-Specific IPython Profile
Following BITS documentation patterns:

```bash
# Create IPython profile for TST beamline
ipython profile create tst-nsls --ipython-dir="~/.ipython"

# Create startup script for the profile
cat > ~/.ipython/profile_tst-nsls/startup/00-start-tst-bits.py << EOF
# TST NSLS-II Beamline IPython Profile Startup
# Auto-load TST BITS instrument package

import pathlib, sys

# Add the bits_deployments path to Python path
tst_bits_path = pathlib.Path().home() / "workspace" / "bAIt" / "bits_deployments" / "tst-nsls-bits"
sys.path.insert(0, str(tst_bits_path / "src"))

# Import the TST instrument
print("Loading TST NSLS-II BITS instrument...")
try:
    from tst_instrument.startup import *
    print("✓ TST instrument loaded successfully")
    print(f"✓ Run Engine: {RE}")
    print(f"✓ Best Effort Callback: {bec}")
    print("Ready for data acquisition!")
except ImportError as exc:
    print(f"✗ Failed to load TST instrument: {exc}")
    print("Please check your BITS installation and paths")
EOF
```

### Step 2.2: Create Convenient Startup Alias
```bash
# Add to ~/.bash_aliases for easy startup
cat >> ~/.bash_aliases << EOF

# TST NSLS-II BITS environment
export TST_BITS_ENV=BITS_tst_env
alias start_tst_bits='conda activate \${TST_BITS_ENV}; ipython --profile=tst-nsls'
alias tst_bits='start_tst_bits'
EOF

# Reload bash aliases
source ~/.bash_aliases
```

## 3. Project Structure Setup

After CLI generation, the structure will be:

```
bits_deployments/tst-nsls-bits/
├── LICENSE (from BITS-Starter)
├── README.md (customize for TST)
├── pyproject.toml (update project metadata)
├── scripts/
│   ├── start-tst-bits.sh (create)
│   └── tiled-serve.sh (migrate from tst-profile-collection)
├── src/
│   ├── tst_instrument/ (generated by create-bits)
│   │   ├── __init__.py
│   │   ├── startup.py (customize)
│   │   ├── configs/
│   │   │   ├── devices.yml (customize)
│   │   │   ├── iconfig.yml (customize)
│   │   │   └── extra_logging.yml
│   │   ├── devices/ (create TST-specific)
│   │   │   ├── __init__.py
│   │   │   ├── motors.py
│   │   │   ├── detectors.py
│   │   │   ├── panda.py
│   │   │   └── flyers.py
│   │   ├── plans/ (create TST-specific)
│   │   │   ├── __init__.py
│   │   │   ├── tomography_plans.py
│   │   │   └── xas_plans.py
│   │   ├── callbacks/
│   │   │   ├── __init__.py
│   │   │   ├── nexus_data_file_writer.py
│   │   │   └── spec_data_file_writer.py
│   │   └── suspenders/
│   │       └── __init__.py
│   └── tst_instrument_qserver/ (generated by create-bits)
│       ├── qs-config.yml
│       ├── qs_host.sh
│       └── user_group_permissions.yaml
└── docs/
    └── tst-exploration.md (this plan document)
```

## 4. Device Files Migration

### List of Device Files to Create:

#### Core Device Files (in src/tst_instrument/devices/):
- **motors.py**: 
  - `rot_motor` using ophyd_async.epics.motor.Motor
  - TST-specific motor configurations with proper NSLS naming
- **detectors.py**: 
  - `manta1`, `manta2` using ophyd_async.epics.advimba.VimbaDetector
  - Camera-specific configurations for TST setup
- **panda.py**: 
  - `panda1` using ophyd_async.fastcs.panda.HDFPanda
  - PandA box configurations with TST trigger setup
- **flyers.py**: 
  - `default_flyer`, `manta_flyer`, `panda_flyer` using StandardFlyer
  - Coordination between devices for synchronized acquisition

### Device Configuration:
Update `configs/devices.yml` with TST device instances:
```yaml
# TST NSLS-II Device Configuration
ophyd_async.epics.motor.Motor:
- name: rot_motor
  prefix: "XF:31ID1-OP:1{CMT:1-Ax:Rot}Mtr"
  labels: ["motors", "rotation", "baseline"]

ophyd_async.epics.advimba.VimbaDetector:
- name: manta1
  prefix: "XF:31ID1-ES:1{Manta:1}"
  labels: ["detectors", "cameras"]
- name: manta2
  prefix: "XF:31ID1-ES:1{Manta:2}"
  labels: ["detectors", "cameras"]

ophyd_async.fastcs.panda.HDFPanda:
- name: panda1
  prefix: "XF:31ID1-ES:1{Panda:1}"
  labels: ["detectors", "triggers", "panda"]
```

## 5. Plans Migration

### List of Plans to Create (in src/tst_instrument/plans/):

#### Core Plan Files:
- **tomography_plans.py**:
  - `tomo_demo_async()` - Migrated from TST 90-plans.py
  - `_manta_collect_dark_flat()` - Dark/flat field collection
  - Proper BITS plan structure with metadata and error handling
- **xas_plans.py**:
  - `xas_demo_async()` - Migrated XAS scanning with proper BITS patterns
  - Energy calibration routines
  - Motor coordination for scanning
- **sim_plans.py**: 
  - Basic simulation plans (generated by create-bits)
  - Test plans for validation

## 6. Configuration Customization

### Key Configuration Updates:
- **pyproject.toml**: 
  ```toml
  name = "tst-nsls-bits"
  description = "TST NSLS-II Beamline BITS Instrument Package"
  ```
- **configs/iconfig.yml**: 
  ```yaml
  RUN_ENGINE:
    DEFAULT_METADATA:
      beamline_id: tst_nsls
      instrument_name: "TST NSLS-II Beamline"
      facility_name: "NSLS-II"
  ```
- **qs-config.yml**: Configure for NSLS environment with proper permissions

## 7. IPython Profile Testing & Usage

### Step 7.1: Test Profile Setup
```bash
# Test the profile loads correctly
ipython --profile=tst-nsls -c "print('TST profile test successful')"

# Start interactive session
tst_bits  # or start_tst_bits
```

### Step 7.2: Validate Instrument Loading
In the IPython session:
```python
# Check that devices loaded
listobjects()  # Should show TST devices

# Test basic functionality  
RE(sim_print_plan())
RE(sim_count_plan())

# Test TST-specific plans (after migration)
RE(tomo_demo_async([manta1], panda1, num_images=5))
```

## 8. Implementation Steps

### Phase 1: CLI Generation & Basic Setup
1. Clone BITS-Starter template to `bits_deployments/tst-nsls-bits`
2. Install BITS environment and CLI tools
3. Run `create-bits tst_instrument` to generate structure
4. Update project metadata and basic configuration

### Phase 2: IPython Profile Setup  
1. Create `tst-nsls` IPython profile
2. Configure startup script to auto-load TST instrument
3. Create convenient bash aliases
4. Test profile loading and basic functionality

### Phase 3: Device Migration
1. Analyze existing TST device definitions
2. Create BITS-compatible device classes with NSLS naming
3. Update device configuration YAML files
4. Test device connectivity and mock mode

### Phase 4: Plans Migration  
1. Port tomography plans from TST 90-plans.py to BITS structure
2. Adapt XAS plans with proper BITS patterns and metadata
3. Add comprehensive error handling and logging
4. Create plan documentation and examples

### Phase 5: Integration & Testing
1. Test complete instrument startup in IPython profile
2. Validate all device connections
3. Test plan execution with mock devices
4. Configure queue server for production use
5. Create startup and management scripts

### Phase 6: Documentation & Deployment
1. Update README with TST-specific instructions
2. Document IPython profile usage and troubleshooting
3. Create user guides for operators
4. Save exploration findings to docs/tst-exploration.md

## 9. Key Benefits of This Approach

- **BITS CLI Integration**: Automated structure generation following best practices
- **IPython Profile**: Seamless integration with existing TST workflow patterns
- **NSLS Compatibility**: Proper NSLS-II naming conventions and metadata
- **Easy Startup**: Simple `tst_bits` command launches complete environment
- **Development-Friendly**: Profile supports both development and production use

## 10. Migration Mapping

### From TST Profile Collection to BITS:
- `startup/00-startup.py` → IPython profile `00-start-tst-bits.py`
- `startup/05-motors.py` → `devices/motors.py` + `configs/devices.yml`
- `startup/15-manta.py` → `devices/detectors.py` + configuration
- `startup/10-panda.py` → `devices/panda.py` + configuration  
- `startup/90-plans.py` → `plans/tomography_plans.py` + `plans/xas_plans.py`
- `user_group_permissions.yaml` → `tst_instrument_qserver/user_group_permissions.yaml`
- `tiled-serve.sh` → `scripts/tiled-serve.sh`

This comprehensive plan ensures full BITS compliance while preserving TST's workflow patterns through IPython profile integration, making the transition seamless for existing users.